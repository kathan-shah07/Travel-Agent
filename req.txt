SYSTEM REQUIREMENTS DOCUMENT

Project: Chat-Based RAG-Grounded Travel Planner (Phase 1)
Mode: Text-only (voice deferred)
Scope: Fixed 3 cities, 1–3 day itineraries

1. SYSTEM OVERVIEW
Objective

Build a conversational AI system that:

Collects structured travel preferences via chat

Generates a feasible, day-wise itinerary

Grounds all facts in public datasets

Explains decisions with citations

Supports partial itinerary edits without global regeneration

2. HIGH-LEVEL SYSTEM COMPONENTS
[Chat UI]
   |
   v
[Conversation Orchestrator]
   |
   +--> Preference Manager
   |
   +--> MCP: POI Search
   |
   +--> MCP: Itinerary Builder
   |
   +--> RAG Retriever
   |
   +--> Explanation Engine
   |
   +--> Evaluation Engine


Each component has a single responsibility and a strict input/output contract.

3. COMPONENT-BY-COMPONENT REQUIREMENTS
3.1 Chat UI
Responsibility

Accept user messages

Display itinerary, explanations, and sources

Render structured itinerary data

Functional Requirements

Text-based input/output

Day-wise itinerary view:

Morning / Afternoon / Evening blocks

Duration per block

Travel time per day

Sources panel listing citations

Input
{
  "user_message": "Plan a 2 day trip to Jaipur"
}

Output

Plain text responses

Structured itinerary visualization

Citation list

Constraints

UI performs no planning logic

UI must not modify itinerary state

3.2 Conversation Orchestrator (Core Brain)
Responsibility

Control system flow

Decide when to ask questions

Route data to MCP tools and RAG

Enforce confirmation before planning

Functional Requirements

Ask clarifying questions only for missing fields

Max 6 clarification turns

Require explicit confirmation before itinerary generation

Detect edit intents vs new planning

Input
{
  "conversation_state": {...},
  "latest_user_message": "I like culture and food"
}

Output

Clarifying question or

Validated preference object or

MCP tool invocation

Invariants

No MCP calls before preference confirmation

No itinerary regeneration unless triggered explicitly

3.3 Preference Manager
Responsibility

Validate, normalize, and store user preferences

Act as the single source of truth

Data Schema
{
  "city": "Jaipur",
  "trip_days": 2,
  "pace": "relaxed",
  "interests": ["culture", "food"],
  "constraints": {
    "avoid_long_travel": true,
    "indoor_preferred": false
  },
  "dates": {
    "start": null,
    "end": null
  }
}

Validation Rules

city ∈ ["Jaipur", "Bengaluru", "Goa"]

trip_days ∈ [1,3]

pace ∈ ["relaxed", "balanced", "packed"]

interests.length >= 1

Failure Handling

Invalid city → graceful refusal

Missing data → clarification question

3.4 MCP Tool: POI Search
Responsibility

Retrieve candidate POIs grounded in OpenStreetMap.

Input Schema
{
  "city": "Jaipur",
  "interests": ["culture", "food"],
  "constraints": {
    "avoid_long_travel": true
  }
}

Internal Logic

Map interests to OSM tags

Query Overpass API within city boundary

Filter POIs:

Must have name

Must have coordinates

Add heuristic visit duration

Output Schema
{
  "pois": [
    {
      "poi_id": "osm:node:123456789",
      "name": "City Palace",
      "category": "culture",
      "location": { "lat": 26.92, "lon": 75.82 },
      "estimated_visit_duration_min": 120
    }
  ],
  "source": "OpenStreetMap"
}

Invariants

Every POI must have an OSM ID

No hallucinated locations allowed

3.5 MCP Tool: Itinerary Builder
Responsibility

Transform POIs into a feasible, structured itinerary.

Input Schema
{
  "pois": [...],
  "trip_days": 2,
  "pace": "relaxed",
  "daily_time_window": {
    "start": "10:00",
    "end": "19:00"
  }
}

Business Rules

Relaxed pace → max 3 POIs/day

Balanced → max 4

Packed → max 5

POIs grouped geographically

Evening blocks biased toward food / low walking

Output Schema
{
  "itinerary": {
    "days": [
      {
        "day": 1,
        "blocks": [
          {
            "time": "morning",
            "poi_id": "osm:node:123",
            "duration_min": 120
          }
        ],
        "estimated_travel_time_min": 40
      }
    ]
  }
}

Constraints

No POI duplication across days

Total daily duration ≤ available time

3.6 RAG Retriever
Responsibility

Retrieve grounded, factual city guidance.

Data Sources

Wikivoyage

Wikipedia

Curated public travel guides

Chunk Schema
{
  "chunk_id": "wiki_jaipur_transport_01",
  "city": "Jaipur",
  "source": "Wikivoyage",
  "section": "Getting Around",
  "text": "Auto-rickshaws are the most practical option..."
}

Retrieval Rules

Filter by city

Top-k semantic matches

Return chunk IDs with text

Constraints

RAG is never used to invent POIs

Missing data must be explicitly stated

3.7 Explanation Engine
Responsibility

Explain why decisions were made, grounded in RAG.

Input
{
  "itinerary": {...},
  "rag_chunks": [...]
}

Output
{
  "explanation": "City Palace was chosen due to its central location and cultural significance.",
  "citations": [
    { "source": "Wikivoyage", "chunk_id": "wiki_jaipur_areas_02" }
  ]
}

Constraints

Every explanation must cite ≥1 source

No generic reasoning allowed

3.8 Evaluation Engine
Responsibility

Continuously validate system output.

Eval 1: Feasibility
- Daily duration ≤ time window
- Travel time ≤ heuristic max
- POIs/day ≤ pace limit

Eval 2: Edit Correctness
- Only edited blocks may change
- Other days must remain identical

Eval 3: Grounding
- All POIs have dataset IDs
- All explanations have citations
- Missing data explicitly acknowledged


Evaluations must be runnable and automated.

4. DATA FLOW (END-TO-END)
User Message
   ↓
Conversation Orchestrator
   ↓
Preference Manager (validate & store)
   ↓
MCP: POI Search
   ↓
MCP: Itinerary Builder
   ↓
Evaluation Engine (feasibility)
   ↓
RAG Retriever (explanations)
   ↓
Explanation Engine
   ↓
UI Rendering + Sources

5. EDIT FLOW (PARTIAL RECOMPUTE)
User Edit Command
   ↓
Edit Intent Parser
   ↓
Identify affected day/block
   ↓
Re-run Itinerary Builder (scoped)
   ↓
Re-run affected evals only

6. NON-FUNCTIONAL REQUIREMENTS

Deterministic outputs for same inputs

Clear failure messages

No silent fallbacks

Versioned itinerary states